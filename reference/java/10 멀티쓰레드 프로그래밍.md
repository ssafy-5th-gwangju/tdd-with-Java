# 들어가면서   
> 목표 : 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.    

[1. 프로세스와 쓰레드](#프로세스와-쓰레드)    
[2. 멀티 쓰레드](#멀티-쓰레드)  
[3. Thread 와 Runnable](#thread-와-runnable)     
[4. 쓰레드의 상태](#쓰레드의-상태)       
[5. Main 쓰레드](#main-쓰레드)         
[6. 데몬 쓰레드](##데몬-쓰레드)      
[7. 쓰레드의 우선순위](#쓰레드의-우선순위)     
[8. 쓰레드의 동기화](#쓰레드의-동기화)      
[9. 교착상태(DeadLock)](##교착상태deadlock)       
[10. 쓰레드를 생성하는 더 좋은 방법](#쓰레드를-생성하는-더-좋은-방법)    


# 프로세스와 쓰레드
프로세스는 운영체제로부터 자원을 할당받는 **작업의 단위**이다.         
쓰레드는 프로세스가 할당 받은 자원을 이용하는 **실행 단위**이다.     
      
![01AEC5FD-FDBA-46FE-8DC5-AC667A9AF33E](https://user-images.githubusercontent.com/50267433/105000222-69eee400-5a71-11eb-96ed-e3b4fc81802f.png)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)
         
비유하자면 야구장에서 **맥주를 파는 사업**을 **프로세스**라 하고          
본사로부터 **맥주를 할당 받아서 판매하는 사람**이 **쓰레드**이다.           
        
![40850_76494_06](https://user-images.githubusercontent.com/50267433/105001975-eb477600-5a73-11eb-85fc-3d9e4f29b563.jpg)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)      
        
**맥주 사업과 더불어 치킨 사업까지** 같이 할 경우     
이를 **멀티 태스킹, 멀티 프로세스**라 말할 수 있고,      
     
**맥주를 할당 받아서 판매하는 사람이 여러명**일 경우       
이를 **멀티 쓰레드**라고 말할 수 있다.                    
                           
우리가 실행하는 **자바 애플리케이션**은 하나의 프로세스이다.                 
애플리케이션 내에서 실행되는 **작업**은 하나의 쓰레드이다.                
    
만약, 하나의 애플리케이션 내에서 여러 작업이 동시에 필요한 경우     
우리는 멀티 쓰레드 방식을 이용해서 해결할 수 있다.    
    
# 멀티 쓰레드     
자바에서는 멀티 쓰레딩을 지원한다.             
그렇다면 **멀티 쓰레딩을 지원하는 이유는 무엇일까?**          
     
현재 우리가 사용하고 있는 대부분의 OS들은 `멀티 프로세스(태스킹)`를 지원한다.               
하지만, `멀티 프로세스`의 경우 **프로세스를 생성하는데 많은 시간이 걸리고**         
프로세스마다 별도의 메모리를 사용하면서 **자원 소모가 많다는 문제가 있었다.**                   
               
이를 해결하고자                   
하나의 프로세스를 다수의 실행 단위로 구분하여 **자원을 공유하고**             
**자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상**시키는 **`멀티 쓰레드`가 등장**했다.             

**멀티 쓰레드의 장점**
* 데이터 영역과 힙 영역을 공유한다. (스택 영역만 비공유)      
* 쓰레드는 프로세스보다 생성 및 컨텍스트 스위칭이 빠르다.    
* 멀티 쓰레드 컨텍스트 스위칭 시 데이터 영역과 힙을 올리고 내릴 필요가 없다.    
* 데이터 영역과 힙 영역을 통해 데이터 교환이 가능하다.   
* 쓰레드 사이에서의 데이터 교환에서는 특별한 기법이 필요없다.    
        
**멀티 쓰레드의 단점**       
* 데이터를 공유하기에 [Race Condition](#race-condition) 이 발생할 가능성이 있다.     
* 이를 해결하기 위해 `동기화`를 사용하지만 `교착상태`가 발생할 수 있다.  
   
## Race Condition     
> 경쟁 상태, 2개 이상의 쓰레드들이 자원을 먼저 사용하려고 경쟁하는 것을 의미   
  
**Race Condition :**              
2개 이상의 `concurrent`한 쓰레드들이 공유된 자원에 접근하려고 할 때                
동기화 메커니즘 없이 접근하려고 하는 상황을 의미하며 데이터간의 불일치성이 발생한다.     
         
코드에서 `Race Condition`이 발생할 수 있는 부분을 `critical section`이라 하며,                     
한 번에 하나의 쓰레드만 `critical section`에 접근하는 기법을 `mutex lock`이라고 한다.             

```java
class MultiThreadTest {
    public static void main(String[] args) {
        Runnable r = new BankThread();
        new Thread(r).start();
        new Thread(r).start();
    }

}

class Account {
    private int balance = 1000;

    public int getBalance() {
        return balance;
    }

    public void withdraw(int money) {
        try {
            Thread.sleep(1000);
        } catch (Exception e) { }
        balance -= money;     // 여기에서 Race Condition 의 문제가 가장 심하다.
    }

}

class BankThread implements Runnable {
    Account acc = new Account();

    @Override
    public void run() {
        while (acc.getBalance() > 0) {
            int money = (int) (Math.random() * 3 + 1) * 100;
            acc.withdraw(money);
            System.out.println("balance:" + acc.getBalance());
        }
    }
}

/* 실행 결과 
 * balance:600
 * balance:600
 * balance:500
 * balance:400
 * balance:200
 * balance:200
 * balance:100
 * balance:100
 * balance:-100
 * balance:-100
 */
```

동기화를 설정하지 않으면 모든 코드에 대해서 Race Condition이 발생한다.      
즉, 둘 이상의 쓰레드들이 하나의 자원을 먼저 사용하려고 경합을 벌이고 있다.     
     
위 경우도 `balance`의 값을 두개의 쓰레드가 각각 동시에 차지하기에     
`balance -= money;`를 하더라도 동기화가 이루어지지 않아 이상한 값이 나오게 된다.    

이를 해결하기 위한 방법으로 동기화가 있다.   
이 부분에 대해서는 아래에서 서술하므로 궁금하다면 해당 [링크](#쓰레드의-동기화)를 타자   
     
# Thread 와 Runnable     
자바에서 쓰레드를 구현할 수 있는 방법은 2가지이다.   

1. Thread 클래스를 상속하여 구현하는 방법        
2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법     
  
## Thread 클래스    
**Thread 클래스**      
```java
class Thread implements Runnable {
    ...     // 생략
    
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null, true);
    }
    
    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }
        
    /* What will be run. */
    private Runnable target;
        
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    ...     // 생략
}
```

* `Thread` 클래스는 정의된 클래스로 `Runnable` 인터페이스를 구현한다.                     
* 당연한 얘기이겠지만, Thread와 관련된 변수 및 상수 그리고 메서드를 제공한다.          
* `Runnable` 인터페이스를 구현하기에 `run()` 메서드가 실제로 정의되어 있는 모습이다.      
* 하지만, `run()` 메서드는 Runnable 인터페이스를 구현한 구현체의 `run()`메서드를 실행만 한다.   
* 즉, 개발자가 Runnable 인터페이스의 구현체를 생성자나 `init()`을  통해 주입시켜줘야 한다.     
          
**Thread 클래스를 상속하여 구현하는 방법**
```java
class MyThread extends Thread {
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```
앞선 코드에서 보았듯이 Thread 클래스는 의존하는 구현체의 run()을 실행한다.           
그렇기에 상속을 이용한 쓰레드를 구현하고자 한다면               
사용자가 직접 `run()` 메서드를 오바리이딩해서 구현해야한다.                

## Runnable 인터페이스     
**Runnable 인터페이스**         
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
* `Runnable` 인터페이스는 `run()`메서드만을 가지고 있는 함수형 인터페이스다.      
* 클래스에서 `Runnable` 인터페이스를 구현해서 `run()` 정의하고 사용해야한다.     
    
**2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법**   
```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
`Runnable` 인터페이스를 구현했다고 해서 쓰레드가 생성되는 것은 아니다.      
`Runnable` 인터페이스 구현체를 Thread 클래스에 생성자를 통해 주입하고    
`Thread` 클래스를 이용해서 쓰레드를 실행해야 한다.  

```java
class Sample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("작업 내용"));
    }
}
```
`Runnable` 인터페이스는 함수형 인터페이스이기에 람다식을 사용할 수 있다.       
     
## Thread VS Runnable    
결론부터 말하자면 `Runnable` 인터페이스를 구현하는 것이 주로 선호되는 방법이다.   
   
```java   
class MyThread extends Thread {     // 상속을 추가로 못하게 된다.    
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```

Runnable을 구현하면 클래스가 유연해진다.   
자바는 단일 상속만 지원하므로 하나의 클래스만 상속할 수 있다.                         
Thread 클래스를 상속받아 `run()`을 구현한 클래스는 더 이상 상속 받을 수 없다.  

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class MyRun2 implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
         thread = new Thread(new MyRun2());           // 작업 교체  
     }
}
```
또한, Thread 상속받아 구현하면 수행하려는 작업은 항상 스레드내에만 존재하게된다.       
그러나 Runnable을 구현하는 경우 다양한 Thread 클래스에서 사용할 수 있다.     
그렇기 때문에, 상속에 자유로운 Runnable 인터페이스를 구현하는 것을 선호한다.           

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
또한, 인터페이스로 구현하면 실행 코드와 쓰레드 구현을 명확하게 구분할 수 있다.     

# 쓰레드의 상태       
쓰레드 프로그래밍을 하다 보면 쓰레드의 행동을 직접 제어해야 할 경우가 생긴다.       

예시로, 공유된 프린터는 1개 밖에 없는데 혼자서 1000장, 10000장을 사용할 수는 없다.         
만약 정말 급하게 프린터를 사용해야하는 사람이 나타난다면          
내가 사용하다가도, 잠시 멈춰주고 자리를 양보하는 것이 서로에게 좋다.       
       
쓰레드도 마찬가지이다.            
긴급한 처리를 요하는 쓰레드가 있을 경우 이를 제어해줘야 프로그램의 성능이 좋아진다.        
  
이처럼 쓰레드도 제어해야 할 필요성이 있는데,      
제어를 하기 전에 해당 스레드의 상태를 알아야 한다.   


![쓰레드 실행 상태](https://user-images.githubusercontent.com/50267433/105578624-e90f4f80-5dc4-11eb-85bc-53d66ed287d9.PNG)     
   
![쓰레드 대기](https://user-images.githubusercontent.com/50267433/105578640-02b09700-5dc5-11eb-8c5c-d3399f2e09b5.PNG)          
       
* 일반적인 쓰레드의 흐름은 **생성`-`실행대기`-`실행-종료** 순이다.                     
* `실행` 상태에서 작업을 모두 수행하기 전에 **일시 정지 상태로 가기도 한다.**        
* 쓰레드 스케줄링에 의해 쓰레드의 순서가 밀릴 수 있기 때문이다. [참고]()
* 다시 실행 상태로 가기 위해서는 일시 정지 상태에서 실행 대기 상태로 가야한다.  
           
자바에서는 `Thread` 클래스의 `getState()` 를 통해 쓰레드의 상태를 알 수 있다.          
`getState()`로 반환되는 쓰레드 상태의 값(열거 상수)은 아래와 같다.        
    
|상태|열거 상수|설명|
|----|--------|---|
|객체 생성|NEW|스레드 객체가 생성, 아직 `start()`가 호출되지 않은 상태|
|실행 대기|RUNNABLE|`start()`가 호출되어 실행 상태 `run()`으로 언제든지 갈 수 있는 상태|	
|일시 정지|WAITING|다른 스레드가 통지할 때까지 기다리는 상태<br>`wait()`, `join()`, `sleep()` 등을 이용해 대기하고 있는 상태|
|일시 정지|TIMED_WAITING|주어진 시간 동안 기다리는 상태<br>`wait()`, `join()`, `sleep()` 등을 이용해 대기하고 있는 상태<br>WAITING과 다르게 메서드의 인수로 최대 대기 시간을 명시할 수 있다.|   
|일시 정지|BLOCKED|사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태|
|종료|TERMINATED|실행을 마친 상태|     
   
**예제**
```java
package com;

public class StatePrintThread extends Thread {
    private Thread targetThread;

    public StatePrintThread(Thread targetThread) {
        this.targetThread = targetThread;
    }

    @Override
    public void run() {
        while (true) {
            Thread.State state = targetThread.getState(); // 스레드 상태 얻기
            System.out.println("타겟 스레드 상태: " + state); // 객체 생성 상태일 경우 실행 대기 상태로 만듬
            if (state == Thread.State.NEW) {
                targetThread.start();
            } // 종료 상태일 경우 while문을 종료함
            if (state == Thread.State.TERMINATED) {
                break;
            }
            try {
                Thread.sleep(500);
            } catch (Exception e) {
            }
        }
    }
}

class TargetThread extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(1500);
        } catch (Exception e) {
        }
        for (long i = 0; i < 1000000000; i++) {
        }
    }
}

class ThreadStateExample {
    public static void main(String[] args) {
        StatePrintThread statePrintThread = new StatePrintThread(new TargetThread());
        statePrintThread.start();
    }
}

/* 실행 결과
 * [원한 값] 
 * 타겟 스레드 상태: NEW
 * 타겟 스레드 상태: RUNNABLE
 * 타겟 스레드 상태: RUNNABLE
 * 타겟 스레드 상태: TIMED_WAITING
 * 타겟 스레드 상태: TIMED_WAITING
 * 타겟 스레드 상태: TIMED_WAITING
 * 타겟 스레드 상태: RUNNABLE
 * 타겟 스레드 상태: RUNNABLE
 * 타겟 스레드 상태: RUNNABLE
 * 타겟 스레드 상태: TERMINATED
 * [실제값]
 * 타겟 스레드 상태: NEW
 * 타겟 스레드 상태: TIMED_WAITING 
 * 타겟 스레드 상태: TIMED_WAITING
 * 타겟 스레드 상태: TIMED_WAITING
 * 타겟 스레드 상태: RUNNABLE
 * 타겟 스레드 상태: TERMINATED
 */
```  
단순하게 쓰레드가 `생성 NEW`되면 실행 대기 상태로 만들고,             
일시 정지가 된 후 다시 실행 대기 상태가 되고 이후 실행하여 끝내는 코드다.              
       
컴퓨터의 성능이 좋아져서 원하는대로 값은 안 나왔지만,         
쓰레드가 `TIMED_WAITING` 후에 다시 `RUNNABLE` 상태가 된 것을 알 수 있다.      

# Main 쓰레드                             
프로그램은 쓰레드 없이 실행할 수 없으므로 적어도 하나의 쓰레드가 필요하다.                     
`JVM`은 각 프로그램에 대한 기본 쓰레드를 제공하며 이를 `Main 쓰레드`라고 부른다.              
             
```java
class Main {
    public static void main(String[] args) {
        ... // Run!  
    }
}
```
우리가 애플리케이션을 구동시킨다면 제일 먼저 `main()`가 호출된다.                   
`main()`은 프로그램을 실행하기 위한 시작 지점이기 때문이다.                                
따라서, 프로그램이 시작하면 `JVM`은 `Main 쓰레드`를 실행시켜 `main()`를 동작시킨다. 
         
자바는 멀티 쓰레드를 지원한다.           
프로그램은 하나의 쓰레드라도 존재하면 종료되지 않는다.         
이는 Main 쓰레드에도 적용되는 규칙이며,            
Main 쓰레드가 종료되어도 다른 쓰레드가 아직 동작중이라면 프로그램은 종료되지 않는다.        
     
**참고로**   
쓰레드가 정상적으로 종료되는 것과 예외가 발생하는 것은 차이가 있다.          
멀티 쓰레드 환경은 같은 프로세스내에 공유된 자원을 활용한다.   
즉, 쓰레드 중 어느 하나라도 문제가 생기면 다른 쓰레드도 영향을 받을 가능성이 높다.      
그렇기에 자바는 멀티 쓰레딩중 어떤 하나의 쓰레드가 문제가 생기면 프로그램을 종료시킨다.      

# 데몬 쓰레드 
데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.         
보조적인 쓰레드이기에 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 종료된다.        
대표적으로, GC(GarbageCollector), 워드프로세서의 자동저장, 화면자동갱신 등이 있다.        

데몬 쓰레드는 일반 쓰레드와 같이 Thread 클래스를 이용해 생성한다. (상속/Runnable구현)   
차이로는, `setDaemon(true)`를 호출하여 Thread 클래스를 데몬쓰레드로 지정하면 된다.      
추가적으로 데몬 쓰레드가 생성한 쓰레드 또한, 자동적으로 데몬 쓰레드가 된다.        
         
```java
void setDaemon(boolean on)    // 쓰레드를 데몬 쓰레드로 or 사용자 쓰레드로 변경한다.       
setDaemon(true)               // 매개변수 on의 값을 true로 지정하면 데몬 쓰레드가 된다.   

boolean isDaemon()            // 쓰레드가 데몬 쓰레드인지 확인하고 데몬 쓰레드면 true를 리턴한다.   
```
데몬 쓰레드는 **무한루프와 조건문을 이용해서 실행 후 대기**하고 있다가        
**특정 조건이 만족되면 작업을 수행하고 다시 대기**하도록 작성한다.               

```java
class DaemonThread implements Runnable {
    static boolean autoSave = false;

    @Override
    public void run() {
        while(true) {
            try {
                Thread.sleep(3 * 1000);	// 3초마다의 간격으로 돈다.   
            } catch(InterruptedException e) {}

            // autoSave의 값이 true이면 autoSave()를 호출한다.
            if(autoSave) {
                autoSave();
            }
        }
    }
    public void autoSave() {
        System.out.println("작업파일이 자동저장되었습니다.");
    }
}

class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new DaemonThread());
        thread.setDaemon(true);
        thread.start();

        for(int i=1; i <= 10; i++) {
            try{
                Thread.sleep(1000);       // 1초 쉰다. 
            } catch(InterruptedException e) {}
            System.out.println(i);

            if(i==5)                      // 5초 이후부터는 autoSave true;
                DaemonThread.autoSave = true;
        }

        System.out.println("프로그램을 종료합니다.");
    }
}
```
3초마다 변수 `autoSave`의 값을 확인해서 그 값이 `true` 이면,           
`autoSave()`를 호출하는 일을 무한히 반복하도록 쓰레드를 작성하였다.
     
`Main 쓰레드[mani()]`는 5초 이후에, `autoSave`를 `true`로 설정했고       
10초 후에 `Main 쓰레드[mani()]`를 종료하도록 코드를 작성했다.      
       
`thread`를 `setDaemon(true)`를 통해 데몬 쓰레드로 설정하지 않았다면,                
`whilt(true)`이기에 강제 종료하지 않는 한 프로그램은 영원히 종료되지 않았을 것이다.         
`setDaemon(true)`를 통해 데몬 쓰레드로 설정했기에 `Main 쓰레드`와 같이 종료가 되었다.     

# 쓰레드의 우선순위       
Thread 클래스는 우선순위(priority)라는 멤버변수를 가지고 있다.     
이 우선순위의 값에 따라 쓰레드가 얻는 실행 시간이 달라진다.   
쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여    
**특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.**       
   
주로, 시각적인 부분이나 사용자에게 빠르게 반응해야하는 작업을 하는 쓰레드의 우선순위는    
다른 작업을 수행하는 쓰레드에 비해 우선순위가 높다.       
(파일/채팅이 있다면, 파일보다 채팅이 우선순위가 높아야하는 경우가 많다.)          
  
**쓰레드의 우선순위 지정하기**    
쓰레드의 우선순위와 관련된 메서드와 상수는 다음과 같다.   
   
```java
void setPriority(int newPriority){}   // 쓰레드의 우선순위를 지정한 값으로 변경한다.   
int getPrirority(){}                  // 쓰레드의 우선순위를 반환한다.  
 
public static final int MAX_PRIORITY = 10;      // 최대우선순위    
public static final int MIN_PRIORITY = 1;       // 최소우선순위   
public static final int NORM_PRIORITY = 5;      // 보통우선순위  
```
쓰레드가 가질 수 있는 우선순위의 범위는 **1~10**이며 숫자가 높을수록 우선순위가 높다.        
  
한 가지 더, 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다.     
`main()`을 수행하는 쓰레드는 우선순위가 5이므로        
**`main()` 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5가 된다.**       

```java
class ThreadEx {
    public static void main(String args[]) {
        ThreadOne th1 = new ThreadOne();      // 쓰레드 생성
        ThreadTwo th2 = new ThreadTwo();      // 쓰레드 생성

        th2.setPriority(7);

        System.out.println("Priority of th1(-) : " + th1.getPriority() );
        System.out.println("Priority of th2(|) : " + th2.getPriority() );
        th1.start();
        th2.start();
    }
}

class ThreadOne extends Thread {
    public void run() {
        for(int i=0; i < 300; i++) {
            System.out.print("-");
            for(int x=0; x < 10000000; x++);
        }
    }
}

class ThreadTwo extends Thread {
    public void run() {
        for(int i=0; i < 300; i++) {
            System.out.print("|");
            for(int x=0; x < 10000000; x++);
        }
    }
}

/* 싱글코어 실행 결과  
* -||-|||||||||||||||||||||||||||||||||||||||||||||||||||---------------------
* ----------------------------------------------------||||||||||||----||||||||
* ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
* ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
* ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||--
* -------------------------------------------------------------------------
* -------------------------------------------------------------------------
* -------------------------------------------------------------------------
*/

/* 멀티코어 실행 결과  
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
* |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
*/
```
쓰레드의 우선순위를 변경하고 싶다면, 쓰레드를 실행하기 전에만 변경해야 한다.    
    
![우선순위가 같을 경우](https://user-images.githubusercontent.com/50267433/105354689-41fbae00-5c34-11eb-9954-6409753029b6.PNG)    
   
위 그림은 윈도우에서 `싱글코어`로 2개의 쓰레드로 2개의 작업을 실행했을 때의 결과이다.    
우선 순위가 같은 경우 각 쓰레드에게 거의 같은 양의 실행 시간이 주어진다.     
   
![우선순위가 다를 경우](https://user-images.githubusercontent.com/50267433/105354857-81c29580-5c34-11eb-9a54-5f7da7ad3ded.PNG)     
   
우선 순위가 다르다면 우선순위가 높은 쓰레드에게 상대적으로 많은 실행시간이 주어진다.  
그렇기에 결과적으로 A가 B보다 더 빨리 작업을 완료할 수 있다.  
   
![우선순위가 같을 경우](https://user-images.githubusercontent.com/50267433/105354689-41fbae00-5c34-11eb-9954-6409753029b6.PNG)       
   
그러나, `멀티코어`에서는 쓰레드의 우선순위에 따른 차이가 거의 없다.                     
쓰레드에 높은 우선순위를 주면 더 많은 실행시간과 기회를 갖는 것을 기대하기는 어렵다.            
**자바는 쓰레드의 우선순위에 따라 많은 시간과 기회를 주는 것을 강제하지 않는다.**           
그저 JVM에게 **메모리,시간이 제한적이라면 우선적으로 처리하도록 권유하는 것 뿐이다.**      
    
굳이, 우선순위에 차등을 두어 스레드를 실행하려면,      
특정 OS의 스케쥴링 정책과 JVM의 구현을 직접 확인해봐야 한다.      
만일 확인한다 하더라도 OS의 스케쥴러에 종속적이라서 예측만 가능할 정도이다.    

차라리 쓰레드에 우선순위를 부여하는 대신 작업에 우선순위를 두어 `PriorityQueue`에 저장해 놓고,      
우선순위가 높은 작업이 먼저 처리되도록 하는 것이 나을 수 있다.        
      
**필자의 생각 :**   
만약 우선순위가 10 이상이면 어떻게 되지? : [참고바람](https://stackoverflow.com/questions/21794411/thread-priority-for-more-than-10-threads-in-java)     
우선 결론만 말하자면, 불가능하다.       
쓰레드의 우선순위는 절대적인 것이 아니며, **JVM에게 권유를 하는 것이다.**        
또한, 만약에 10개 이상의 쓰레드를 동시에 사용해야 하는 경우가 발생했다면                  
이는 애초에 프로그램을 잘못 설계 했을 가능성이 높다.                 

# 쓰레드의 동기화
멀티 쓰레드의 경우,            
여러 쓰레드가 동일한 프로세스 내의 자원을 공유해서 사용하기 때문에              
`Race Condition`과 같이 쓰레드간의 작업에 영향을 줄 수 있다.          
즉, 원래 의도했던 결과가 아닌 **엉뚱하고 치명적인 결과를 불러일으킬 수 있다.**   
      
이러한 문제를 발생시키지 않기 위해서는         
특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다.        
그래서 도입된 개념이 바로 **임계영역(critical section)** 과 **잠금(lock)** 이다.      
  
![1](https://user-images.githubusercontent.com/50267433/105116605-69585b00-5b0e-11eb-97e9-a2e7bc89eaea.PNG)    
         
공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고,              
공유 데이터가 가지고 있는 `lock`을 획득한 하나의 쓰레드만 코드를 수행할 수 있게 한다.         
그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만       
다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 된다.    
  
이처럼 **한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것**을      
**'쓰레드의 동기화'** 라고 부른다.           
  
## synchronized
`synchronized` 키워드는 임계 영역을 설정하는데 사용된다.     
`synchronized` 키워드를 사용해 임계 영역을 설정하는 방법은 2가지가 있다.     

1. 메서드 전체를 임계 영역으로 지정 
2. 특정한 영역을 임계 영역으로 지정 
    
```java
// 1. 메서드 전체를 임계 영역으로 지정 
public synchronized void calcSum() {
    // ...
}

// 2. 특정한 영역을 임계 영역으로 지정 
synchronized (객체_참조변수) {
    // ...
}
```

**메서드 전체를 임계 영역으로 지정**   
```java
    public synchronized  void withdraw(int money) {
        if(balance >= money) {
            try {
                Thread.sleep(1000);
            } catch (Exception e){}
            balance -= money;
        }
    }
```
'메서드 전체를 임계 영역으로 지정'하는 방법은       
메서드 앞에 `synchronized` 키워드를 붙이는 것이다.        
`synchronized` 키워드를 붙이면 메서드 전체가 임계 영역으로 설정된다.    
   
쓰레드는 `synchronized 메서드`가 호출된 시점부터      
**해당 메서드가 포함된 객체의 `lock`** 을 얻어 작업을 수행하다가      
메서드가 종료되면 `lock`을 반환한다.        
        
**특정한 영역을 임계 영역으로 지정**            
```java
    public void withdraw(int money) {
        synchronized(this){
            if(balance >= money) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e){}
                balance -= money;
            }    
        }
    }
```
메서드 내의 코드 일부를 블럭`{}`으로 감싸고 이를 임계 영역으로 설정한다.             
이때 **참조변수는 락을 걸고자하는 객체를 참조하는 것이어야 한다.**          

우리는 2가지 방법을 통해 임계 영역을 설정해주었다.   
2가지 방법 모두 lock의 획득과 반납이 모두 자동적으로 이루어진다.   
      
임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면             
메서드 전체 보다 `synchronized 블럭`으로 임계 영역을 최소화하여 락을 거는 것이 좋다.          
      
**예시**      
은행계좌에서 잔고를 확인하고 임의의 금액을 출금하는 코드를 살펴볼 것이다.      
아래 코드를 보면 잔고가 출금하려는 금액보다 큰 경우에만 출금하도록 정의되어 있다.      
```java
    public void withdraw(int money) {
        if (balance >= money) {                 // 여긴 통과했는데
            try { 
                Thread.sleep(1000); 
            } 
            catch (Exception e) { }
            balance -= money;                   // 여기를 빼앗겼다.   
        }
    }
```
하지만, 실행 결과를 보면 잔고(balance)가 음수인 것을 볼 수 있다.       
그 이유는 한 쓰레드가 if문의 조건식을 통과하고 출금하기 바로 직전에           
다른 쓰레드가 끼어 들어서 출금을 먼저 했기 때문이다.           
즉, 서로 자원을 먼저 사용하려고 뺏으려 경쟁하는 `Race Condiion`이 발생했다.       
           
쉽게 설명하면 두 쓰레드 모두 `if 문`을 통과했지만,             
어느 한 쓰레드가 먼저 출금해 잔고가 마이너스가 된 상황이다.            
그렇기에 잔고를 확인하는 `if 문`과 출금하는 문장은 하나의 임계 영역으로 묶여져야 한다.     

```java
    public synchronized  void withdraw(int money) {
        if(balance >= money) {
            try {
                Thread.sleep(1000);
            } catch (Exception e){}
            balance -= money;
        }
    }
```
```java
    public void withdraw(int money) {
        synchronized(this){
            if(balance >= money) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e){}
                balance -= money;
            }    
        }
    }
```
* 앞서 배웠던 2가지 방법으로 임계 영역을 지정해 동기화를 진행할 수 있다.          

```java
class MultiThreadTest {
    public static void main(String[] args) {
        Runnable r = new BankThread();
        new Thread(r).start();
        new Thread(r).start();
    }

}

class Account {
    private int balance = 1000;

    public int getBalance() {
        return balance;
    }

    public void withdraw(int money) {
        synchronized (this){
            if (balance >= money) {
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) { }
                balance -= money;
            }
        }
    }
}

class BankThread implements Runnable{
    Account acc = new Account();

    @Override
    public void run() {
        while (acc.getBalance() > 0){
            int money = (int)(Math.random() * 3 +1) * 100;
            acc.withdraw(money);
            System.out.println("balance:"+acc.getBalance());
        }
    }
}

/* 실행 결과
 * 
 * balance:900
 * balance:800
 * balance:700 
 * balance:400
 * balance:200
 * balance:0
 * balance:0
 */
```
   
## Lock 클래스 
동기화할 수 있는 방법은 `synchronized` 키워드 외에도          
`java.util.concurrent.locks` 패키지가 제공하는 `lock` 클래스들을 이용하는 방법이 있다.       
  
`synchronized`블럭으로 동기화를 하면 자동적으로 lock이 잠기고 풀리기 때문에 편하다.      
심지어 `synchronized`블럭 내에서 예외가 발생해도 lock은 자동적으로 풀린다.          
하지만, 때로는 같은 메서드 내에서만 `lock`을 걸수 있다는 제약이 불편하기도 하다.    
그럴 때 lock 클래스를 사용한다.  
   
lock 클래스의 종류는 3가지가 있다.    

* **ReetrantLock :** 재진입이 가능한 lock, 가장 일반적인 배타 lock       
* **ReetrantReadWriteLock :** 읽기에는 공유적이고, 쓰기에는 배타적인 lock     
* **StampedLock :** ReetrantReadWriteLock에 낙고나적인 lcok의 기능을 추가   
     
**ReetrantLock**    
```java
    private int balance = 1000;
    private ReentrantLock lock = new ReentrantLock();

    public int getBalance() {
        lock.lock();                            // lock 시작
        int curBalance = this.balance;
        try {
            curBalance = this.balance;
        } finally {
            lock.unlock();                      // lock 종료
        }
        return curBalance;
    }
```
* 가장 일반적인 lock 이다.       
* **재진입(ReetrantLock)** 이라는 이름 그대로       
특정 조건에서 lock을 풀고 나중에 다시 lock을 얻고 이후의 작업을 수행할 수 있다.       
* `ReetrantLock`는 배타적인 lock이라서 무조건 lock이 있어야만 코드를 수행할 수 있다.  
  
**ReetrantReadWriteLock**     
```java
    private int balance = 1000;
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    
    public int getBalance() {
        lock.readLock().lock();                 // 읽기 lock 시작
        int curBalance = this.balance;
        try {
            curBalance = this.balance;
        } finally {
            lock.readLock().unlock();            // 읽기 lock 종료
        }
        return curBalance;
    }
    
    public void withdraw(int money) {
        lock.writeLock().lock();                // 쓰기 lock 시작
        try {
            if (balance >= money) {
                balance -= money;
            }
        }finally {
            lock.writeLock().unlock();          // 쓰기 lock 종료
        }
    }    
```
* `읽기를 위한 lock`과 `쓰기를 위한 lock`을 제공한다.         
* `ReetrantReadWriteLock`는 `읽기 lock`이 걸려있어도               
**다른 쓰레드가 읽기 lock을 중복해서 걸고 읽기를 수행할 수 있다.**                
* 읽기는 내용을 변경하지 않으므로 동시에 여러 쓰레드가 읽어도 문제가 되지 않는다.          
* 그러나 `쓰기 lock`을 걸거나 사용하는 경우, 다른 쓰레드와의 중복은 불가능하다.        
  
**StampedLock**    
```java
    private int balance = 1000;
    private StampedLock lock = new StampedLock();

    public int getBalance() {
        long stamp = lock.tryOptimisticRead();        // 낙관적 읽기 lock을 건다.
        int curBalance = this.balance;                // 공유데이터인 balance를 가져온다.  

        if (lock.validate((stamp))) {                 // 쓰기 lock에 의해 낙관적인 읽기 lock이 풀렸는지 확인
            stamp = lock.readLock();                  // lock이 풀렸으면, 일반 읽기 lock을 얻으려고 기다린다.   

            try {
                curBalance = this.balance;            // 공유 데이터를 다시 읽어온다.  
            } finally {                   
                lock.unlockRead(stamp);               // 읽기 lock을 푼다.  
            }

        }
        return curBalance;                            // 낙관적 읽기 lock이 풀리지 않으면 곧바로 읽어온 값을 반환   
    }
```   
* lock 을 걸거나 해지할 때 스탬프(long 정수값)사용하며,        
* 읽기와 쓰기를 위한 lock외에 '낙관적 읽기 lock'가 추가된 것이다.       
* 읽기 lock이 걸려있으면, 쓰기 lock을 사용하기 위해 읽기 lock이 풀리기를 기다려야 한다.     
* 하지만, '낙관적인 읽기 lcok'를 사용하면 '쓰기 lock'에 의해 바로 풀린다.       
* 그래서 만약, '낙관적인 읽기 lcok'에 실패한다면, 읽기 lock을 다시 읽어와야 한다.      
* 무조건 읽기 lock 을 걸지 않고,       
**쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후에 읽기 lock을 거는 것이다.**       

## volatile

```java
class Main {
    public static void main(String args[]) {
        UserThread r1 = new UserThread();
        UserThread r2 = new UserThread();
        UserThread r3 = new UserThread();
        Thread th1 = new Thread(r1, "*");
        Thread th2 = new Thread(r2, "**");
        Thread th3 = new Thread(r3, "***");

        th1.start();
        th2.start();
        th3.start();

        try {
            Thread.sleep(2000);
            r1.suspend();		// th1.suspend()ÀÌ ¾Æ´Ô¿¡ ÁÖÀÇ
            Thread.sleep(2000);
            r2.suspend();
            Thread.sleep(3000);
            r1.resume();
            Thread.sleep(3000);
            r1.stop();
            r2.stop();
            Thread.sleep(2000);
            r3.stop();
        } catch (InterruptedException e) {}
    }
}

class UserThread implements Runnable {
    boolean suspended = false;
    boolean stopped    = false;

    public void run() {
        while(!stopped) {
            if(!suspended) {
                System.out.println(Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch(InterruptedException e) {}
            }
        }
        System.out.println(Thread.currentThread().getName() + " - stopped");
    }

    public void suspend() { suspended = true;  }
    public void resume()  { suspended = false; }
    public void stop()    { stopped   = true;  }
}
```
위 코드는 멀티 코어 프로세서가 장착된 컴퓨터에서 문제가 발생할 가능성이 있다.   
멀티 코어 프로세서에서는 코어마다 별도의 캐시를 가지고 있기 때문이다.    
   
![volatile](https://user-images.githubusercontent.com/50267433/105577512-823a6800-5dbd-11eb-863c-8a05e61d2a52.PNG)      
   
코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업한다.              
값을 다시 읽어올 때는 먼저 캐시에 있는지 확인하고 없을 때만 메모리에서 읽어온다.             
       
그러다보니 도중에 메모리에 저장된 벼수의 값이 변경되었는데도          
캐시에 저장된 값이 갱신되지 않아서 메모리에 저장된 값이 다른 경우가 발생한다.      

```java
volatile boolean suspended = false;
volatile boolean stopped = false;
```
`volatile` 키워드를 붙이면 **캐시가 아닌 메모리에서 직접 값을 읽어온다.**     
   
```java
public synchronized void stop()    { 
    stopped = true;
}
```
참고로 `synchronized` 키워드를 사용해도 같은 효과를 얻을 수 있다.         
`synchronized` 영역을 들어갈 때와 나올 때,        
**캐시와 메모리간의 동기화**가 이루어지기 때문에 값의 불일치가 해소된다.   
      
**long 과 double 원자화**       
JVM은 데이터를 `4 byte` 단위로 처리하기에,       
`int`보다 작은 타입들은 한 번에 읽거나 쓰는 것이 가능하다.        
   
즉, 단 하나의 명령어로 읽거나 쓰기가 가능하다는 뜻이다.        
하나의 명령어는 더 이상 나눌 수 없는 최소의 작업단위이므로,    
**작업의 중간에 다른 쓰레드가 끼어들 틈이 없다.**     
    
그러나, 크기가 `8byte`인 `long`과 `double` 타입의 변수는           
하나의 명령어로 값을 읽거나 쓸 수 없기 때문에,               
변수의 값을 읽는 과정에 다른 쓰레드가 끼어들 여지가 있다.      
   
이를 해결하기 위해 `long`이나 `double`을 쓰는 문장에 `synchronized`를 사용해도 되지만,   
변수를 선언할 때 `volatile` 키워드를 붙이면 된다.   

```java
volatile long sharedVal;   
volatile double sharedVal;    
```

`volatile` 키워드를 사용한 변수는 읽거나 쓰기에 대해 원자화가된다.         
단, `volatile` 변수는 원자화가 되는 것이지 동기화가 되는 것은 아니다.       
그렇기 때문에, 동기화가 필요할 때는 `synchronized`를 사용해야한다.        

```java
volatile long balance;              // 원자화  

synchronized int getBalance() {
    return balance;   
}

synchronized void withdraw(int money) {
    if(balance >= money) {
        balance -= money;
    }   
}
```

# 교착상태(DeadLock)   
둘 이상의 쓰레드가 `lock`을 획득하기 위해 기다리는데,         
`lock`을 잡고 있는 쓰레드도 똑같이 다른 `lock`을 기다리며 서로 블록 상태에 놓이는 것을 말한다.          
교착상태는 다수의 쓰레드가 같은 `lock`을, 동시에, 다른 명령에 의해, 획득하려 할 때 발생한다.        
   
![DeadLock](https://user-images.githubusercontent.com/50267433/105572142-ae8fbd80-5d98-11eb-826b-36db0b85f9a2.PNG)    
  
```java
Thread 1  locks A, waits for B
Thread 2  locks B, waits for A
```
일반적으로 애해하기 쉬운 교착상태는 위와 같은 형태이며   

```java
Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A
```
크게 싸이클을 도는 형태로 교착상태가 발생할 수 도 있다.   
         
**교착상태 조건**         
교착상태는 아래에 기술된 **4가지가 조건을 모두 모두 만족해야 발생한다.**                   
         
|조건이름|설명|
|-------|----|
|**상호배제 (Mutual Exclusion)** |한 순간에 한 프로세스만이 자원을 사용할 수 있다.<br>즉, 한 프로세스에 의해 점유된 자원을 다른 프로세스들이 접근할 수 없다.|
|**점유대기 (Hold and Wait)** |이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다리고 있다.|
|**비선점 (No preemption)** |프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 빼앗을 수 없다.|
|**환형대기 (Circular Wait)** |프로세스간에 닫힌 연결이 존재할 경우<br>블록된 프로세스가 자원을 점유하고 있는데<br>이 자원을 다른 프로세스가 원하며 대기하고 있는 상태|  
             
**교착상태**를 발생시킨다고해서 이 조건들이 잘못된 조건은 아니다.             
예시로, `상호배제`는 수행 결과의 일관성과 데이터베이스의 무결성을 위해 반드시 필요하다.           
단지, 4가지 원칙들은 교착상태를 발생시킬 수 있다는 가능성이 있다는 것이고                 
원칙을 최대한 지키면서 교착상태가 발생하지 않는 코드를 작성해야 한다는 것을 말하고 싶다.          
       
아래 코드는 java를 이용해 교착상태가 발생한 것을 나타내주는 한 예시다.   
   
**실제 코드 예시**     
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class Node {
    public int data = 0;

    public void setData(int data) {
        this.data = data;
    }

    public int getData() {
        return this.data;
    }
}

class Example {
    private static void sleep() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void sum(Node n1, Node n2) {
        for (int i = 0; i < 10; i++) {
            synchronized (n1) {
                synchronized (n2) {
                    int data = n1.getData();
                    n1.setData(data + i);
                    data = n2.getData();
                    n2.setData(data + i);
                }
            }
            System.out.println(Thread.currentThread().getName() + " i = " + i);
            sleep();
        }
    }

    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(2);
        final Node node1 = new Node();
        final Node node2 = new Node();
        try {
            Future<?> f1 = service.submit(() -> {
                sum(node1, node2);
            });
            Future<?> f2 = service.submit(() -> {
                sum(node2, node1);
            });
            f1.get();
            f2.get();
        } catch (Throwable e) {
            e.printStackTrace();
        }
        service.shutdown();
        System.out.println("Node data - " + node1.getData());
        System.out.println("Node data - " + node2.getData());
    }
}
```
* 소스 코드는 ['명월 일지'님의 블로그에서 참조했다.](https://nowonbun.tistory.com/300)            
* 2개의 쓰레드에 동작에서 서로 다른 Node객체를 lock 하고 원하면서 교착상태가 발생했다.              

이런 교착 상태에 빠지지 않기 위해서는 **`synchronized`안에 `synchronized`를 만들면 안 된다.**       
그러나 함수 안에 함수로 작성된다고 하면 구분하기 어렵기에 쉽지는 않다.            
    
**함수로 분리했을 경우 synchronized가 안 보이는 현상**    
```java
    private static void add(Node n1, Node n2, int i) {
        synchronized (n2) {
            int data = n1.getData();
            n1.setData(data + i);
            data = n2.getData();
            n2.setData(data + i);
        }
    }

    private static void sum(Node n1, Node n2) {
        for (int i = 0; i < 10; i++) {
            synchronized (n1) {
                add(n1, n2, i);
            }
            System.out.println(Thread.currentThread().getName() + " i = " + i);
            sleep();
        }
    }
```
* `sum()`의 일부분을 `add()`로 분리했다.       
* 위 코드는 거리가 가까워 구분이 되지만, 그렇지 않을 경우 중첩`synchronized`를 알긴 힘들다.           
    
만약, 위 코드와 같이 `synchronized`의 중첩을 피할 수 없으면 어떻게 하지?              
중첩을 피할 수 없으면 **`synchronized`를 하나로 통일하는 방법이 있다.**      
  
**변경 전**
```java
    private static void add(Node n1, Node n2, int i) {
        synchronized (n2) {
            int data = n1.getData();
            n1.setData(data + i);
            data = n2.getData();
            n2.setData(data + i);
        }
    }

    private static void sum(Node n1, Node n2) {
        for (int i = 0; i < 10; i++) {
            synchronized (n1) {
                add(n1, n2, i);
            }
            System.out.println(Thread.currentThread().getName() + " i = " + i);
            sleep();
        }
    }
```  
**변경 후**     
```java
    private static synchronized void add(Node n1, Node n2, int i) {
        int data = n1.getData();
        n1.setData(data + i);
        data = n2.getData();
        n2.setData(data + i);
    }

    private static void sum(Node n1, Node n2) {
        for (int i = 0; i < 10; i++) {
            add(n1, n2, i);
            System.out.println(Thread.currentThread().getName() + " i = " + i);
            sleep();
        }
    }
```
Node클래스의 객체를 각각 따로 따로 동기화 처리를 하는 것이 아닌,      
Example 클래스의 메서드 단위로 동기화를 묶어서 처리하는 방식을 진행한다.      
즉, Node 객체를 동기화 하는 것이 아니라 Example 객체를 동기화 한 것이다.   
                  
이 방법은 세밀한 동기화가 되지 않기 때문에 성능이 많이 떨어질 수 있다.                    
하지만, 성능은 떨어질지 언정 데드락은 확실히 피할 수 있다는 장점이 있다.    
  
**추가적으로**     
교착상태는 교착상태를 일으키는 조건 4가지를 모두 만족하면 발생한다.     
즉, 조건 4가지중 1가지라도 지키지 않을 경우 교착상태를 피할 수 있다.    
   
![예방](https://user-images.githubusercontent.com/50267433/105574264-b5bdc800-5da6-11eb-834a-77b5037aed79.PNG)    

# 쓰레드를 생성하는 더 좋은 방법  
## 쓰레드 풀 
쓰레드의 생성과 소멸은 그 자체로 시스템에 부담을 주는 일이다.   
따라서 처리해야 할 일이 있을때마다 쓰레드를 생성하는 것은 성능의 저하로 이어진다.    

**쓰레드 풀** 은 미리 제한된 갯수의 쓰레드를 생성한 후 쓰레드가 필요한 시점에 해당 쓰레드를 할당해주는 기술이다.      
즉, 쓰레드가 할당되었다가 작업이 끝나면 스레드를 소멸시키지 않고 다시 쓰레드 풀에서 대기하도록 만드는 기술이다.      
   
**쓰레드 풀 예시**  
```java
public class ExecutorDemo {

    public static void main(String[] args) throws InterruptedException {
        Runnable task1 = () -> {
            int n1 = 10;
            int n2 = 20;
            String name = Thread.currentThread().getName();
            System.out.println(name + ": " + (n1 + n2));
        };

        ExecutorService exr = Executors.newSingleThreadExecutor();
        exr.submit(task1);

        System.out.println("End " + Thread.currentThread().getName());
        exr.shutdown();
    }
}
```
```java
        ExecutorService exr = Executors.newSingleThreadExecutor();
```
해당 코드를 통해서 쓰레드풀을 생성하였다.   
쓰레드 풀에도 여러 종류가 있는데 이는 아래와 같다.   
  
1. **`Executors.newSingleThreadExecutor()`** : 1개의 쓰레드만 생성한 쓰래드 풀을 리턴한다.   
2. **`Executors.newFixedThreadPool(int n)`** : 인자로 들어온 숫자만큼(int)의 쓰레드만 생성한 쓰래드 풀을 리턴한다.   
3. **`Executors.newCachedThreadPool()`** : 쓰레드의 갯수를 유동적으로 관리하는 쓰레드 풀을 리턴한다.         

```java
        exr.shutdown();
```   
생성된 쓰레드 풀과 그 안에 있는 쓰레드를 해제하고자 할 때 사용되는 메서드이다.          
쓰레드의 특성상 미리 작업이 진행되고 있을 수 있는데 그러더라도 작업을 마친후 해제를 진행하도록 되어있다.        

## Callable & Future    
기존 `Runnable` 인터페이스의 `run()` 메서드는 **인자값도 없으면 반환값도 없었다.**    
그런데 만약 **반환값이 필요한 경우**가 있다면 어떻게 해야할까?       
  
이럴때 사용하고자 하는 것이 바로 `Callable` 인터페이스다.    

**Callable.interface**
```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```   
이제 해당 인터페이스를 어떻게 활용하는지 살펴보겠다.   

**Collable 활용 예시**
```java
package com.company;

import java.util.concurrent.*;

public class CallableDemo {

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Callable<Integer> task = () -> {
          int sum = 0;
          for (int i = 0; i < 10; i++){
              sum += i;
          }
            return sum;
        };
        
        ExecutorService exr = Executors.newSingleThreadExecutor();
        Future<Integer> fur =  exr.submit(task);
        Integer value = fur.get();
        System.out.println("result: " + value);
        exr.shutdown();
    }
}
```
```java
    <T> Future<T> submit(Callable<T> task);
```

`ExecutorService` 참조변수의 `submit()` 메서드는           
`Runnable` 외에도 `Collable` 인스턴스를 받을 수 있게 오버로딩 되어있다.             
   
```java
        Future<Integer> fur =  exr.submit(task);
```
단, `Future<T>`로 리턴하기에 해당 인스턴스를 참조하는 변수로 받아줘야 한다.      
    
참고로 필자가 한번 추적하고자 했는데 `Collable`, `Future` 둘다 단순히 인터페이스여서  
내부적으로 동작을 한후 `Future` 를 구현한 어떤 인스턴스를 반환하고   
해당 인스턴스가 오버 라이딩한 `get()` 메서드를 통해 값을 얻어올 수 있다.      

## 컬렉션 인스턴스 동기화           
동기화는 특성상 어쩔 수 없이 성능의 저하를 수반한다.               
이런 이유로 컬렉션 프레임워크의 대부분의 클래스들은 동기화 처리가 되어있지 않다.                
대신 `Collections` 는 특정 메서드를 통한 동기화 방법을 제공하고 있다.      

```java
    public static <T> Set<T> synchronizedSet(Set<T> s)
    public static <T> List<T> synchronizedList(List<T> list)
    public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)
    public static <T> Collection<T> synchronizedCollection(Collection<T> c)
```
아니 더 정확히 말하면 동기화 클래스 제공 및 동기화 메서드를 제공해준다. (동기화 클래스도 구현되어있음)     
   
동기화 방법은 간단하다.         
해당 메서드의 인자값으로 알맞는 컬렉션 프레임워크 인스턴스를 넣고 반환된 인스턴스를 사용하면 된다.      
    
**사용법**    
```java
        List<Integer> arrayList = Collections.synchronizedList(Arrays.asList(1,2,3));
```
단순 `List<E>` 같지만 동기화 사용토록 조정된 `List 인스턴스`이다.    

**잘못된 예시**
```java
package com.company;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


public class SyncArrayList {
    public static List<Integer> lst = Collections.synchronizedList(new ArrayList<>());

    public static void main(String[] args) throws InterruptedException {
        for(int i=0; i < 16; i++){
            lst.add(i);
        }
        System.out.println(lst);
        
        Runnable task = () -> {
            ListIterator<Integer> itr = lst.listIterator();
            while (itr.hasNext()){
                itr.set(itr.next() + 1);
            }
        };

        ExecutorService exr = Executors.newFixedThreadPool(3);
        exr.submit(task);
        exr.submit(task);
        exr.submit(task);
        
        exr.shutdown();
        exr.awaitTermination(100, TimeUnit.SECONDS);
        System.out.println(lst);

    }
}
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
// [1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]
```
어라 근데 값이 이상하게 나왔다.         
우리는 분명 증가 계산식을 3번을 사용했는데 1씩 또는 2씩만 증가가 된것이다.           
어째서지? 분명  `Collections.synchronized컬렉션()` 메서드를 사용하면 동기화가 된다고 했는데     
   
이유는 바로 **Iterator에서 동기화가 이루어지지 않았기 때문이다.**    
컬렉션 인스턴스가 동기화 되었다 하더라도 이를 기반으로 생성된 반복자까지 동기화가 이루어지지 않았기 때문이다.   
  
이를 조금더 설명하자면 
`lst.listIterator();` 동기화 처리 되었다.   
해당 메서드를 사용할때 다른 쓰레드가 해당 클래스내의 다른 메서드를 호출하지 못한다.   
하지만 해당 메서드는 `ListIterator`를 반환하는 기능만 한다.      
즉, `listIterator()` '사용' 에서만 동기화가 되었지 이후에는 전혀 관련이 없는 것이다.         
   
그럼 어떻게 처리를 해주어야 할까?          
우리는 앞서 동기화 블록을 사용했다.            
그리고 동기화 블록은 this를 사용했지만 사실 this도 자기자신 인스턴스라는 의미이므로           
다르게 생각하면 **다른 인스턴스들도 동기화 블록을 사용 가능하다는 것을 알 수 있다.**              

**사용법**
```java
        Runnable task = () -> {
            synchronized (lst){
                ListIterator<Integer> itr = lst.listIterator();
                while (itr.hasNext()){
                    itr.set(itr.next() + 1);
                }
            }
        };
```
`synchronized()`에는 `itr`가 아닌 **`lst`** 가 와야한다.      
이유는 간단하다.        
해당 블록 내에서 `itr 메서드`를 동기화 하는 것이 아니라           
**`lst`**에 존재하는 값과 메서드를 동기화 시켜서 Race Condition이 일어나지 않도록 해야하기 때문이다.**        
즉, 다른 쓰레드들은 lst 접근하지 못하도록 하는 것이다.   

**전체 코드**
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


public class SyncArrayList {
    public static List<Integer> lst = Collections.synchronizedList(new ArrayList<>());

    public static void main(String[] args) throws InterruptedException {
        for(int i=0; i < 16; i++){
            lst.add(i);
        }
        System.out.println(lst);

        Runnable task = () -> {
            synchronized (lst){
                ListIterator<Integer> itr = lst.listIterator();
                while (itr.hasNext()){
                    itr.set(itr.next() + 1);
                }
            }
        };

        ExecutorService exr = Executors.newFixedThreadPool(3);
        exr.submit(task);
        exr.submit(task);
        exr.submit(task);

        exr.shutdown();
        exr.awaitTermination(100, TimeUnit.SECONDS);
        System.out.println(lst);

    }
}
```  
# 다루지 않은 내용  
  
1. `start()`와 `run()`의 차이 - 추가 예정
2. 쓰레드 그룹
3. 쓰레드의 실행 제어 
4. wait() 와 notify() - 추가 예정  
5. Codtion 을 이용한 Lock
6. fork & joim 프레임워크  
7. Concurrent / Thread-safe / 1000개의 요청 controller는?

# 참고   
[자바의 정석 - 서적](http://www.yes24.com/Product/Goods/24259565)    
[윤성우의 열혈 자바 프로그래밍 - 서적](http://www.yes24.com/Product/Goods/43755519)       
[parkcheolu님의 블로그](https://parkcheolu.tistory.com/19)    
[widevery님의 블로그](https://widevery.tistory.com/27)       
[예비개발자님의 블로그](http://blog.naver.com/PostView.nhn?blogId=qbxlvnf11&logNo=220921178603&parentCategoryNo=&categoryNo=12&viewDate=&isShowPopularPosts=true&from=search)
